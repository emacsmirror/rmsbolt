* RMSbolt

An implementation of the [[https://github.com/mattgodbolt/compiler-explorer][godbolt compiler-explorer]] for Emacs.

RMSBolt tries to make it easy to see what your compiler is doing. It does this
by showing you the assembly output of a given source code file. It also
highlights which source code a given assembly block corresponds to, and vice
versa. It supports more types of languages than any previous tool of it's kind.

* Why RMSbolt over godbolt?

- No more sending your code to any server
- Much faster turnaround time from writing code to seeing and interacting with disassembly
- 100% usable without the mouse.
- Runs entirely without node, npm, or js.
  - No required dependencies other than Emacs 25 and your compiler ~:)~
  - It's easy to add new languages (even those that use unique bytecode formats)
    without touching many files.
  - Dosen't eat your ram on the 'server' or the 'client'
  - No enforced limits on code size, compilation time, or processing time.
- Benefits from living in Emacs
  - Full undo tree from Emacs on disassembly/source so you don't loose work.
  - Vim bindings through evil/viper.
  - Use compile.el, flymake, or flycheck to traverse and fix errors as you
    would normally.
  - Use *any* libraries on your machine trivially.
  - Customize colors and behavior through ~customize~.
  - Change tracking through magit/diff-hl/etc.
  - Nyans are fully supported with nyan-mode.
- Much more flexible and powerful
  - Supports disassembling to bytecode as well as assembly
  - Supports many languages that godbolt does not support, such as python,
    common lisp, ocaml, and java.
- Simpler
- Infinitely hackable!

* Installation

rmsbolt will almost certainly not work naively on windows as it depends on a
unix shell for building the compilation commands. It may work through cygwin
though.

** Melpa

[[http://melpa.org/#/rmsbolt][A melpa package is available for rmsbolt]].

** Quelpa

#+BEGIN_SRC emacs-lisp
  (quelpa '(rmsbolt
            :files (:defaults "starters")
            :fetcher gitlab
            :repo "jgkamat/rmsbolt"))
#+END_SRC

* Running
 Once installed, use the ~rmsbolt-lang~ functions to generate starter files, or
 enable ~rmsbolt-mode~ in a supported language. Then run ~rmsbolt-compile~ or
 use the default ~C-c C-c~ binding. After the first run, the buffer should
 automatically update.

* Demos
** C/C++

[[https://s25.postimg.cc/c1zj5ghr3/sihr1g.gif]]

** OCaml

[[https://s25.postimg.cc/s088vljov/Pab_Aq2.gif]]

** Rust

demangling is done with rustfilt if available

[[https://s25.postimg.cc/h7npjnnun/output-2018-08-01-19_30_52.gif][https://s25.postimg.cc/h7npjnnun/output-2018-08-01-19_30_52.gif]]

** Haskell

demangling is done with the compiler-explorer demangler, named
to ~haskell-demangler~.

[[https://s25.postimg.cc/4d5167yr3/output-2018-08-08-23_17_59.gif][https://s25.postimg.cc/4d5167yr3/output-2018-08-08-23_17_59.gif]]

** Python

Support for viewing bytecode only. Python [[https://bugs.python.org/issue2506][doesn't have many options]], so most
tweakables will not work. Python 3.7 is required for recursion into functions,
otherwise only top level code will be shown. Python 2 is unsupported.

[[https://s25.postimg.cc/594qd9o4v/output-2018-08-04-18_07_45.gif][https://s25.postimg.cc/594qd9o4v/output-2018-08-04-18_07_45.gif]]

** Java

Parses the output of ~javap~, so may be a little unreliable or buggy at the
moment.

[[https://s25.postimg.cc/57s2z9uxb/output-2018-09-01-00_29_30.gif][https://s25.postimg.cc/57s2z9uxb/output-2018-09-01-00_29_30.gif]]
** Common Lisp

No support for source->asm matching or filtering.

[[https://s25.postimg.cc/uhk02ugfz/1_FB9k7.gif]]

* Adding a Language

Adding support for a new language is fairly easy. The closer it is to existing
compilers, the easier it will be (to the point where a clone of a C compiler is
just a couple copy-paste lines). However, it is not excessively hard to add
support for completely foreign compilers and bytecode/assembly formats.

As a minimum starting point, you must know how to compile a source file to
assembly or bytecode on the command line, and know how the line numbers are
available in the compiled form if they exist.

1. [[file:rmsbolt.el::;;;;%20Language%20Definitions][Add a new entry to the language definitions statement.]]
   - To do this, you will need to (at a minimum) add a mode, compile-command, a
     compile-cmd-function, and a starter file name.
   - The compile-cmd-function is a function that will turn local variable
     settings into a valid command which will take in a filename and output
     assembly or an executable. See ~rmsbolt--c-compile-cmd~ for an example.
   - If the assembly is not in a standard format, you will need to define a
     ~process-asm-custom-fn~ as well (see python/java for examples).
2. [[file:rmsbolt.el::;;;;;%20Starter%20Definitions][Add a new entry into the starter file]]
   - For this, you will need to make a starter file. See [[file:starters/][this folder]] for
     existing examples.

You're done!

* Alternatives
- [[https://github.com/yawkat/javap][yawkat/javap]]
- [[https://github.com/mattgodbolt/compiler-explorer][mattgodbolt/compiler-explorer]]
- [[http://reliant.colab.duke.edu/c2mips/][c2mips]]
